//@author: a0111794e



	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\DatePair.java
	 */

/**
 * This DatePair class is used to store a pair of date in the form of Calendar
 * object which represent the possible start date and end date.
 */
public class DatePair implements Serializable {

    private Calendar startDate = null;
    private Calendar endDate = null;

    private static final int EMPTY_ARRAYLIST_SIZE = 0;

    /**
     * Basic Constructor for DatePair, create a DatePair without any
     * initialization.
     */
    public DatePair() {
        this.startDate = null;
        this.endDate = null;

    }

    /**
     * Overloaded Constructor for DatePair, create a DatePair with only endDate
     * If one date is present, it will be taken as end date.
     *
     * @param endDate the endDate of the task
     */
    public DatePair(Calendar endDate) {
        this.endDate = endDate;
        this.startDate = null;
    }

    /**
     * Overloaded constructor for DatePair, create DatePair with startDate and
     * endDate If start Date entered is later then endDate, it will be swapped.
     * over
     *
     * @param startDate the starting date of the task
     * @param endDate   the ending date of the task
     */
    public DatePair(Calendar startDate, Calendar endDate) {
        if (startDate.equals(endDate)) {
            startDate = null;
            this.endDate = endDate;
        } else if (startDate.after(endDate)) {
            this.startDate = endDate;
            this.endDate = startDate;
        } else {
            this.startDate = startDate;
            this.endDate = endDate;
        }
    }

    /**
     * Get the startDate of the task.
     *
     * @return starting date of the task
     */
    public Calendar getStartDate() {
        return this.startDate;
    }

    /**
     * Get the endDate of the task.
     *
     * @return ending date of the task
     */
    public Calendar getEndDate() {
        return this.endDate;
    }

    /**
     * Set the startDate of the task.
     *
     * @param startDate the date when the task starts
     */
    public void setStartDate(Calendar startDate) {
        this.startDate = startDate;
    }

    /**
     * Set the endDate of the task.
     *
     * @param endDate the date when the task ends
     */
    public void setEndDate(Calendar endDate) {
        this.endDate = endDate;
    }

    /**
     * Check if the task has startDate.
     *
     * @return if the task has startDate
     */
    public boolean hasStartDate() {
        return (this.startDate != null);
    }

    /**
     * Check if the task has endDate.
     *
     * @return if the task has endDate
     */
    public boolean hasEndDate() {
        return (this.endDate != null);
    }

    /**
     * Check if the task has DateRange.
     *
     * @return if the task has DateRange
     */
    public boolean hasDateRange() {
        return (this.startDate != null && this.endDate != null);
    }

    /**
     * Check if the task has endDate.
     *
     * @return if the task has endDate
     */
    public boolean isDeadline() {
        return (!hasStartDate() && hasEndDate());
    }

    /**
     * Overwrite the default to string value of task Formatted for RubberDuck
     * console design.
     *
     * @return String value of DatePair
     */
    @Override
    public String toString() {
        String formattedStartDate, formattedEndDate;
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MMM-YYYY HH:ss",
                                                           Locale.US);

        if (hasStartDate()) {
            formattedStartDate = dateFormat.format(startDate.getTime());
        } else {
            formattedStartDate = "[No Start Date]";
        }

        if (hasEndDate()) {
            formattedEndDate = dateFormat.format(endDate.getTime());
        } else {
            formattedEndDate = "[No End Date]";
        }

        return String.format("%s %s", formattedStartDate, formattedEndDate);

    }

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\DatePair.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\DatePair.java
	 */

    /**
     * Check if any end date in the DateList has already past the current date
     * and time during execution.
     *
     * @param dateList the ArrayList of DatePair
     * @return true if there is a date that has already past else false
     */
    public static boolean isDateBeforeNow(ArrayList<DatePair> dateList) {
        if (dateList.size() > EMPTY_ARRAYLIST_SIZE) {
            for (DatePair dp : dateList) {
                if (dp.getEndDate().before(Calendar.getInstance())) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }

}

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\DatePair.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\Task.java
	 */

/**
 * This task class is used to represent a single task object which stores all
 * relevant information about the task and provide the needed getters and
 * setters for retrieval and storage.
 */
public class Task implements Serializable, Comparable<Task> {

    private String description;
    private ArrayList<DatePair> dateList;
    private boolean isDone;
    private String uuid;
    private Calendar lastUpdate;

    private static final int BIGGER = 1;
    private static final int SMALLER = -1;
    private static final int SAME = 0;

    /**
     * Creates a task with no fields. This should only be used by Java Bean.
     */
    public Task() {

    }

    /**
     * Creates a task with notes field only.
     *
     * @param description notes about the task
     */

    public Task(String description) {
        this(description, new ArrayList<DatePair>());
    }

    /**
     * Creates a task with notes and DatePair fields.
     *
     * @param description about the task
     * @param dateList    of possible DatePair
     */
    public Task(String description, ArrayList<DatePair> dateList) {
        this.description = description;
        this.dateList = dateList;
        this.isDone = false;
        updateLastUpdate();
        resetUuid();
    }

    /**
     * Change the description of the notes.
     *
     * @param description of the task
     */
    public void setDescription(String description) {
        this.description = description;
        updateLastUpdate();
    }

    /**
     * Returns the description of the class.
     *
     * @return the description of the class
     */
    public String getDescription() {
        return description;
    }

    /**
     * Set a new dateList of the Task object.
     *
     * @param dateList of possible DatePair
     */

    public void setDateList(ArrayList<DatePair> dateList) {
        this.dateList = dateList;
        updateLastUpdate();
    }

    /**
     * Check if there is at least a start date or end date.
     *
     * @return if there exist at least a date
     */
    public boolean hasDate() {
        for (DatePair dp : dateList) {
            if (dp.hasEndDate() || dp.hasStartDate()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns an ArrayList of DatePair.
     *
     * @return the dateList of possible DatePair
     */

    public ArrayList<DatePair> getDateList() {
        return dateList;
    }

    /**
     * Add an end date to the task without a start date.
     *
     * @param endDate the dateline of the task
     */

    public void addEndDate(GregorianCalendar endDate) {
        DatePair dp = new DatePair(endDate);
        dateList.add(dp);
        updateLastUpdate();
    }

    /**
     * Adds another DatePair into DatePairList.
     *
     * @param datePair datePair to add
     */
    public void addDatePair(DatePair datePair) {
        dateList.add(datePair);
        updateLastUpdate();
    }

    /**
     * Update the task to set it to complete.
     *
     * @param isDone whether the task is completed
     */

    public void setIsDone(boolean isDone) {
        this.isDone = isDone;
        updateLastUpdate();
    }

    /**
     * Check if the status is completed.
     *
     * @return if the task is completed
     */

    public boolean getIsDone() {
        return isDone;
    }

    /**
     * Return UUID of the task.
     *
     * @return UUID as String
     */
    public String getUuid() {
        return uuid;
    }

    /**
     * Set UUID of the task.
     *
     * @param uuid UUID to be set
     */
    public void setUuid(String uuid) {
        this.uuid = uuid;
        updateLastUpdate();
    }

    /**
     * Get the task last updateTime as Calendar.
     *
     * @return Calendar format of last update time of the task
     */
    public Calendar getLastUpdate() {
        return this.lastUpdate;
    }

    /**
     * Update the task last updateTime (For Google Sync).
     */
    public void updateLastUpdate() {
        this.lastUpdate = Calendar.getInstance();
    }

    /**
     * Check if the dateList is empty.
     *
     * @return if the dateList is empty
     */
    public boolean isDateListEmpty() {
        return dateList.isEmpty();
    }

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\Task.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\Task.java
	 */

    /**
     * Compare both task by their deadline.
     * <p/>
     * Schedule Task > Deadline Task > Floating Task
     *
     * @param o the task object to be compared with the argument
     * @return int ,  0 = equal, -1 = smaller, 1 = bigger
     */
    @Override
    public int compareTo(Task o) {
        assert (o != null);

        if (this.isSchedule() && !o.isSchedule()) {
            return SMALLER;
        } else if (!this.isSchedule() && o.isSchedule()) {
            return BIGGER;
        }

        if (this.isFloatingTask() && o.isFloatingTask()) {
            return SAME;
        } else if (this.isFloatingTask()) {
            return BIGGER;
        } else if (o.isFloatingTask()) {
            return SMALLER;
        }

        return this.getEarliestDate().compareTo(o.getEarliestDate());

    }

    /**
     * Method used to check whether a task has any potential conflicting
     * schedule in current database.
     *
     * @param dbManager DatabaseManager object to interact with
     * @return true if there is a conflict else false
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    public boolean checkConflictWithDB(DatabaseManager<Task> dbManager,
                                       long thisTaskId) throws IOException {
        if (isFloatingTask() || isDeadline()) {
            return false;
        }

        ArrayList<Long> validIDList = dbManager.getValidIdList();
        for (Long i : validIDList) {
            Task storedTask = dbManager.getInstance(i);
            if (i != thisTaskId && !storedTask.getIsDone()) {
                if (hasConflictWith(storedTask)) {
                    return true;
                }
            }
        }

        return false;
    }
}

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\Task.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\AddCommand.java
	 */

/**
 * Concrete Command Class that can be executed to add a new task (floating,
 * deadline, schedule and tentative) into the database.
 */
public class AddCommand extends Command {

    private static final String MESSAGE_ADD_FLOAT_SUCCESS =
        "\"%s\" has been successfully added.";
    private static final String MESSAGE_ADD_DEADLINE_SUCCESS =
        "\"%s\" has been successfully added on %s.";
    private static final String MESSAGE_ADD_TIMED_SUCCESS =
        "\"%s\" has been successfully added from %s.";
    private static final String MESSAGE_ADD_TENTATIVE_SUCCESS =
        "\"%s\" has been successfully added tentatively on your specified dates.";
    private static final String MESSAGE_ADD_PAST =
        "\"%s\" cannot be added as the end date has already passed the current time.";
    private static final String MESSAGE_ERROR_WRONG_TASK_TYPE =
        "Tentative task must be strictly for schedule(s) only. No deadline(s) are allowed.";
    private static final String MESSAGE_SCHEDULE_CONFLICT =
        "Please note that there are conflicting schedule(s). Plan well!";
    private static final String MESSAGE_ADD_START =
        "Adding tasks into database...";
    private static final String JOURNAL_MESSAGE_ADD =
        "Added task \"%s\"";

    private String description;
    private ArrayList<DatePair> datePairs;

    /**
     * Public constructor for AddCommand that accepts description and the list
     * of DatePairs.
     *
     * @param description of the task
     * @param datePairs   list of datePairs if any
     */
    public AddCommand(String description, ArrayList<DatePair> datePairs) {
        this.description = description;
        this.datePairs = datePairs;
    }

    /**
     * Getter method for description.
     *
     * @return description as String
     */
    protected String getDescription() {
        return description;
    }

    /**
     * Getter method for datePairs.
     *
     * @return datePairs as ArrayList<DatePair>
     */
    protected ArrayList<DatePair> getDatePairs() {
        return datePairs;
    }

    /**
     * Create and add the task to the database.
     *
     * @return the correct response back to the user
     * @throws IOException DBManager has encountered an IO Error
     */
    @Override
    public Response execute() throws IOException {
        assert datePairs != null;
        assert description != null;
        assert !description.equals("");

        if (DatePair.isDateBeforeNow(datePairs)) {
            String errorMessage = ColorFormatter.format(
                String.format(MESSAGE_ADD_PAST, description), Color.RED);
            return new Response(errorMessage, false);
        }

        Task task = new Task(description, datePairs);

        if (!task.checkValidity()) {
            String errorMessage = ColorFormatter.format(
                MESSAGE_ERROR_WRONG_TASK_TYPE, Color.RED);
            return new Response(errorMessage, false);
        }

        String recordDesc = Formatter.limitDescription(task.getDescription());

        LOGGER.info(MESSAGE_ADD_START);
        long id = getDbManager().modify(null, task,
                                        String.format(JOURNAL_MESSAGE_ADD,
                                                      recordDesc));
        assert id >= 0 : "ID should never be a negative number.";

        boolean hasConflict = task.checkConflictWithDB(getDbManager(), id);

        /* Build Response to the User */
        StringBuilder messages = new StringBuilder();
        if (task.isTentative()) {
            messages.append(ColorFormatter.format(String.format(
                MESSAGE_ADD_TENTATIVE_SUCCESS, recordDesc), Color.YELLOW));
        } else if (task.isFloatingTask()) {
            messages.append(ColorFormatter.format(
                String.format(MESSAGE_ADD_FLOAT_SUCCESS, recordDesc),
                Color.YELLOW));
        } else if (task.isDeadline()) {
            messages.append(ColorFormatter.format(String.format(
                MESSAGE_ADD_DEADLINE_SUCCESS, recordDesc,
                task.getDateString()), Color.YELLOW));
        } else if (task.isSchedule()) {
            messages.append(ColorFormatter.format(String.format(
                MESSAGE_ADD_TIMED_SUCCESS, recordDesc,
                task.getDateString()), Color.YELLOW));
        }

        LOGGER.info(messages.toString());

        if (hasConflict) {
            messages.append(System.lineSeparator());
            messages.append(ColorFormatter.format(MESSAGE_SCHEDULE_CONFLICT,
                                                  Color.RED));
        }

        Response res = getPreviousDisplayCommand().execute();
        res.setMessages(messages.toString());
        return res;
    }
}

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\AddCommand.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\SearchCommand.java
	 */

/**
 * Concrete Command Class that can be executed to search the data store for
 * tasks containing the provided keyword and returns back the task details.
 */
public class SearchCommand extends Command {

    private static final String MESSAGE_SEARCH_RESULT =
        "%s task with \"%s\" has been found.";

    private static final int FIRST_CHAR = 0;
    private static final int SECOND_CHAR = 1;
    private static final int CHAR_LENGTH_OFFSET = 1;
    private static final int EMPTY_KEYWORDS_LENGTH = 2;
    private static final int ONE_WORD = 1;

    /* Information required for search */
    private String keyword;

    /**
     * Public constructor of SearchCommand.
     *
     * @param keyword that is used to search for the task
     */
    public SearchCommand(String keyword) {
        this.keyword = keyword;
    }

    /**
     * Getter method for keyword.
     *
     * @return String object
     */
    protected String getKeyword() {
        return keyword;
    }

    /**
     * Search for task based on description and return a Response containing
     * formatted string of tasks back to parent.
     *
     * @return Response object containing formatted tasks
     * @throws IOException that might be thrown from dbManager
     */
    @Override
    public Response execute() throws IOException {
        setPreviousDisplayCommand(this);
        getDisplayedTasksList().clear();

        for (Long databaseId : getDbManager().getValidIdList()) {
            boolean isFound = false;
            String taskDescription =
                getDbManager().getInstance(databaseId).getDescription();
            taskDescription = taskDescription.toLowerCase();
            StringTokenizer taskDescriptions =
                new StringTokenizer(taskDescription);
            StringTokenizer keywords =
                new StringTokenizer(keyword.toLowerCase());

            if (keyword.length() > EMPTY_KEYWORDS_LENGTH &&
                keyword.charAt(FIRST_CHAR) == '\"' &&
                keyword.charAt(keyword.length() - CHAR_LENGTH_OFFSET) == '\"') {

                String modifiedKeyword = keyword.substring(SECOND_CHAR,
                                                           keyword.length() -
                                                           CHAR_LENGTH_OFFSET);
                isFound = searchExactKeyword(modifiedKeyword, taskDescriptions);

            } else if (keywords.countTokens() == ONE_WORD) {
                isFound = searchSingleKeyword(keyword, taskDescription);
            } else {
                isFound = searchMultipleKeyword(keywords, taskDescriptions);
            }
            if (isFound) {
                getDisplayedTasksList().add(databaseId);
            }
        }

        Color headerColor = getDisplayedTasksList().isEmpty() ? Color.RED
                                                              : Color.GREEN;

        StringBuilder viewCount = new StringBuilder();
        viewCount.append(ColorFormatter.format(
            String.format(MESSAGE_SEARCH_RESULT, getDisplayedTasksList().size(),
                          keyword), headerColor));

        String taskData = Formatter.formatTaskList(getDisplayedTasksList(),
                                                   getDbManager());
        return new Response("", viewCount.toString(), taskData);
    }

    /**
     * Complementing searchMultipleKeyword.
     * <p/>
     * When search are being called, if keyword used in search contains only a
     * single word, this method will be called.
     * <p/>
     * This will actually check if the description itself contains the word and
     * return the value immediately
     * <p/>
     * To eliminate the getting unwanted result due to searching with
     * meaningless keywords
     *
     * @param keyword
     * @param taskDescription
     * @return if the description of the task contains the keyword.
     */
    private boolean searchSingleKeyword(String keyword,
                                        String taskDescription) {
        return taskDescription.toLowerCase().contains(keyword.toLowerCase());
    }

    /**
     * This method allows user to search for exact keyword, thus if " " are
     * used, only description that consist of exact same words will be shown.
     *
     * @param keyword
     * @param taskDescriptions tokenized taskDescription
     * @return if the description of the task contains the keyword.
     */
    private boolean searchExactKeyword(String keyword,
                                       StringTokenizer taskDescriptions) {

        while (taskDescriptions.hasMoreElements()) {

            String nextToken = taskDescriptions.nextToken();
            if (nextToken.equalsIgnoreCase(keyword)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Complementing searchSingleKeyword.
     * <p/>
     * When search are being called, if keyword used in search contains more
     * than a word, this method will be called.
     * <p/>
     * This will actually check if the description itself contains exactly all
     * the keyword as entered by the user
     * <p/>
     * To eliminate the getting unwanted result due to searching with
     * meaningless keywords
     *
     * @param keyword
     * @param taskDescription
     * @return if the description of the task contains the keyword.
     */
    private boolean searchMultipleKeyword(StringTokenizer keywords,
                                          StringTokenizer taskDescriptions) {
        String firstKeyword = keywords.nextToken();
        while (taskDescriptions.hasMoreElements()) {
            if (taskDescriptions.nextToken().equals(firstKeyword)) {
                if (keywords.countTokens() <= taskDescriptions.countTokens()) {
                    // check remaining keyword
                    while (keywords.hasMoreElements()) {
                        if (!keywords.nextToken()
                            .equals(taskDescriptions.nextToken())) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
        }
        return false;
    }
}

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\SearchCommand.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\ViewCommand.java
	 */

/**
 * Concrete Command Class that can be executed to return related tasks as a
 * formatted String based on various input upon creation.
 */
public class ViewCommand extends Command {

    /**
     * Enumeration of all types of view filter
     */
    public enum ViewFilter {
        FLOATING, DEADLINE, SCHEDULE
    }

    /**
     * Enumeration of all types of view type
     */
    public enum ViewType {
        ALL, DATE, PREV, OVERDUE
    }

    private static final String MESSAGE_VIEWALL_RESULT =
        "You have %s incomplete task(s) in total.";
    private static final String MESSAGE_VIEWDATE_RESULT =
        "You have %s incomplete task(s) %s.";
    private static final String MESSAGE_VIEWALL_CRESULT =
        "You have %s completed task(s) in total.";
    private static final String MESSAGE_VIEWDATE_CRESULT =
        "You have %s completed task(s) %s.";
    private static final String MESSAGE_VIEWOVERDUE_RESULT =
        "You have %s overdue tasks(s) in total.";
    private static final String MESSAGE_DATE_RANGE =
        "from %s to %s";
    private static final String MESSAGE_ONE_DAY =
        "on %s";
    private static final String MESSAGE_VIEWTYPE_TASK_ALERT =
        "Please note that all task have no date, thus it will be omitted in your agenda.";

    private static final int VIEW_FILTER_ALL_SELECTED = 3;
    private static final int VIEW_FILTER_ONE_SELECTED = 1;
    private static final int VIEW_FILTER_NONE_SELECTED = 0;

    private static final ArrayList<ViewFilter> VIEW_SELECTION_ALL =
        new ArrayList<ViewFilter>(
            Arrays.asList(ViewFilter.DEADLINE, ViewFilter.SCHEDULE,
                          ViewFilter.FLOATING));

    private DatePair viewRange;
    private boolean completed;
    private ViewType viewType;
    private ArrayList<ViewFilter> viewSelection;

    /**
     * Public constructor for ViewCommand.
     *
     * @param viewType      the type of view to execute
     * @param completed     true if all completed tasks should be returned
     *                      instead
     * @param viewRange     date range to view tasks in
     * @param viewSelection specified view scope from user
     */
    public ViewCommand(ViewType viewType, boolean completed, DatePair viewRange,
                       ArrayList<ViewFilter> viewSelection) {
        this.viewType = viewType;
        this.completed = completed;
        this.viewRange = viewRange;
        if (viewSelection != null && viewSelection.isEmpty()) {
            this.viewSelection = VIEW_SELECTION_ALL;
        } else {
            this.viewSelection = viewSelection;
        }
    }

    /**
     * Getter method for viewRange.
     *
     * @return viewRange as DatePair
     */
    protected DatePair getViewRange() {
        return viewRange;
    }


    /**
     * Getter method for completed.
     *
     * @return completed as boolean
     */
    protected boolean isCompleted() {
        return completed;
    }

    /**
     * Getter method for viewType.
     *
     * @return viewType as ViewType
     */
    protected ViewType getViewType() {
        return viewType;
    }

    /**
     * Getter method for viewSelection.
     *
     * @return viewSelection as ArrayList
     */
    protected ArrayList<ViewFilter> getViewSelection() {
        return viewSelection;
    }

    /**
     * Check the type of view method requested by user.
     *
     * @return Response object containing the result of the view option
     * @throws IOException that might occur
     */
    @Override
    public Response execute() throws IOException {
        switch (viewType) {
            case ALL:
                return viewAll();

            case DATE:
                return viewByPeriod();

            case OVERDUE:
                return viewOverdue();

            case PREV:
                return viewPrev();

            default:
                throw new UnsupportedOperationException();
        }
    }

    /**
     * Return all the valid task stored in the database.
     *
     * @return Response object containing result of all tasks
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    private Response viewAll() throws IOException {
        assert viewSelection != null;

        getDisplayedTasksList().clear();

        for (int i = 0; i < getDbManager().getValidIdList().size(); i++) {
            Long databaseId = getDbManager().getValidIdList().get(i);
            Task task = getDbManager().getInstance(databaseId);
            if (completed == task.getIsDone() && viewSelection.
                contains(getTaskType(task))) {
                getDisplayedTasksList().add(databaseId);
            }
        }

        Color headerColor = getDisplayedTasksList().isEmpty() ? Color.GREEN
                                                              : Color.YELLOW;

        Color cHeaderColor = getDisplayedTasksList().isEmpty() ? Color.YELLOW
                                                               : Color.GREEN;
        StringBuilder viewCount = new StringBuilder();
        if (completed) {
            String formattedString = String.format(MESSAGE_VIEWALL_CRESULT,
                                                   getDisplayedTasksList().
                                                       size());
            viewCount.append(ColorFormatter.format(formattedString,
                                                   cHeaderColor));
        } else {
            String formattedString = String.format(MESSAGE_VIEWALL_RESULT,
                                                   getDisplayedTasksList()
                                                       .size());
            viewCount.append(ColorFormatter.format(formattedString,
                                                   headerColor));
        }

        setPreviousDisplayCommand(this);
        String taskData = Formatter.formatTaskList(getDisplayedTasksList(),
                                                   getDbManager());
        return new Response("", viewCount.toString() + " "
                                + viewSelectionToString(), taskData);
    }

    /**
     * Return overdue tasks in database, based on user selections
     *
     * @return Response object containing result of all tasks
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    private Response viewOverdue() throws IOException {
        assert viewSelection != null;

        getDisplayedTasksList().clear();

        for (int i = 0; i < getDbManager().getValidIdList().size(); i++) {
            Long databaseId = getDbManager().getValidIdList().get(i);
            Task task = getDbManager().getInstance(databaseId);
            if (taskOverdueValidity(task)) {
                getDisplayedTasksList().add(databaseId);
            }
        }
        Color headerColor = getDisplayedTasksList().isEmpty() ? Color.GREEN
                                                              : Color.YELLOW;
        StringBuilder viewCount = new StringBuilder();
        String formattedString = String.format(MESSAGE_VIEWOVERDUE_RESULT,
                                               getDisplayedTasksList().size());
        viewCount.append(ColorFormatter.format(formattedString, headerColor));

        setPreviousDisplayCommand(this);
        String taskData = Formatter.formatTaskList(getDisplayedTasksList(),
                                                   getDbManager());
        return new Response("" + taskFilterAlert(), viewCount.toString() + " "
                                                    + viewSelectionToString(),
                            taskData);
    }

    /**
     * Checks if the task has a deadline, if it is overdue and if it fits user
     * filter criteria
     *
     * @param task the task to check
     * @return if it fits search criteria
     */
    private boolean taskOverdueValidity(Task task) {
        return (task.isDeadline() || task.isSchedule()) &&
               !task.getIsDone() && viewSelection.contains(getTaskType(task)) &&
               task.getDateList().get(0).getEndDate()
                   .before(Calendar.getInstance());
    }

    /**
     * Searches the Database for a related task that coincides with the
     * dateRange requested.
     *
     * @return Response object containing result of all tasks within range
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    private Response viewByPeriod() throws IOException {
        assert viewSelection != null;
        assert viewRange != null;

        getDisplayedTasksList().clear();
        for (Long databaseId : getDbManager().getValidIdList()) {
            Task task = getDbManager().getInstance(databaseId);
            if (completed == task.getIsDone() && task.hasDate() &&
                viewSelection.contains(getTaskType(task))) {
                if (task.isWithinPeriod(viewRange)) {
                    getDisplayedTasksList().add(databaseId);
                }
            }
        }

        String range = "";
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd MMM", Locale.US);
        if (viewRange.hasDateRange()) {
            String startDate =
                dateFormat.format(viewRange.getStartDate().getTime());
            String endDate =
                dateFormat.format(viewRange.getEndDate().getTime());

            if (!startDate.equals(endDate)) {
                range = String.format(MESSAGE_DATE_RANGE, startDate, endDate);
            } else {
                range = String.format(MESSAGE_ONE_DAY, endDate);
            }
        } else {
            assert false : "This should not occur as there must be a date.";
        }

        Color headerColor = getDisplayedTasksList().isEmpty() ? Color.GREEN
                                                              : Color.YELLOW;
        StringBuilder viewCount = new StringBuilder();
        if (completed) {
            viewCount.append(ColorFormatter.format(String.format(
                MESSAGE_VIEWDATE_CRESULT, getDisplayedTasksList().size(),
                range), headerColor));
        } else {
            viewCount.append(ColorFormatter.format(String.format(
                MESSAGE_VIEWDATE_RESULT, getDisplayedTasksList().size(),
                range), headerColor));
        }

        setPreviousDisplayCommand(this);
        String taskData = Formatter.formatTaskList(getDisplayedTasksList(),
                                                   getDbManager());
        String header = viewCount.toString() + " " + viewSelectionToString();
        return new Response("" + taskFilterAlert(), header, taskData);
    }

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\ViewCommand.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\ViewCommand.java
	 */

    /**
     * Retrieve the viewType based on the task provided.
     *
     * @param task object to get type
     * @return ViewFilter of the object
     */
    private ViewFilter getTaskType(Task task) {
        if (task.isFloatingTask()) {
            return ViewFilter.FLOATING;
        } else if (task.isDeadline()) {
            return ViewFilter.DEADLINE;
        } else {
            return ViewFilter.SCHEDULE;
        }
    }

    /**
     * Returns user required filters in string
     *
     * @return String feedback of user requested filters
     */
    private String viewSelectionToString() {

        String viewSelectionList = "[";

        if (viewSelection.size() == VIEW_FILTER_ALL_SELECTED
            || viewSelection.size() == VIEW_FILTER_NONE_SELECTED) {
            viewSelectionList += "All";
        } else {
            for (int i = 0; i < viewSelection.size(); i++) {
                viewSelectionList += viewSelection.get(i);
                if (i < viewSelection.size() - 1) {
                    viewSelectionList += ", ";
                }
            }
        }
        return ColorFormatter.format(viewSelectionList + "]", Color.CYAN);
    }

    /**
     * Check if it is view by dateRange, and return message to warn that the
     * search will be omitted
     *
     * @return String containing the alert message if there is any
     */
    private String taskFilterAlert() {
        String alert = "";
        if (viewSelection.contains(ViewFilter.FLOATING)) {
            alert += MESSAGE_VIEWTYPE_TASK_ALERT;
        }
        return ColorFormatter.format(alert, Color.RED);
    }
}

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\ViewCommand.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\menu\UnixInterface.java
	 */

    /**
     * Setup and instantiates the ConsoleReader from jLine.
     *
     * @return ConsoleReader object
     * @throws IOException occurs when ConsoleReader has problem with output
     */
    private ConsoleReader setupConsoleReader() throws IOException {
        ConsoleReader cr = new ConsoleReader();
        cr.clearScreen();
        cr.setPrompt(DEFAULT_PROMPT);
        setCompleter(cr);
        setKeybinding(cr);
        return cr;
    }

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\menu\UnixInterface.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\DatePair.java
	 */

/**
 * This DatePair class is used to store a pair of date in the form of Calendar
 * object which represent the possible start date and end date.
 */
public class DatePair implements Serializable {

    private Calendar startDate = null;
    private Calendar endDate = null;

    private static final int EMPTY_ARRAYLIST_SIZE = 0;

    /**
     * Basic Constructor for DatePair, create a DatePair without any
     * initialization.
     */
    public DatePair() {
        this.startDate = null;
        this.endDate = null;

    }

    /**
     * Overloaded Constructor for DatePair, create a DatePair with only endDate
     * If one date is present, it will be taken as end date.
     *
     * @param endDate the endDate of the task
     */
    public DatePair(Calendar endDate) {
        this.endDate = endDate;
        this.startDate = null;
    }

    /**
     * Overloaded constructor for DatePair, create DatePair with startDate and
     * endDate If start Date entered is later then endDate, it will be swapped.
     * over
     *
     * @param startDate the starting date of the task
     * @param endDate   the ending date of the task
     */
    public DatePair(Calendar startDate, Calendar endDate) {
        if (startDate.equals(endDate)) {
            startDate = null;
            this.endDate = endDate;
        } else if (startDate.after(endDate)) {
            this.startDate = endDate;
            this.endDate = startDate;
        } else {
            this.startDate = startDate;
            this.endDate = endDate;
        }
    }

    /**
     * Get the startDate of the task.
     *
     * @return starting date of the task
     */
    public Calendar getStartDate() {
        return this.startDate;
    }

    /**
     * Get the endDate of the task.
     *
     * @return ending date of the task
     */
    public Calendar getEndDate() {
        return this.endDate;
    }

    /**
     * Set the startDate of the task.
     *
     * @param startDate the date when the task starts
     */
    public void setStartDate(Calendar startDate) {
        this.startDate = startDate;
    }

    /**
     * Set the endDate of the task.
     *
     * @param endDate the date when the task ends
     */
    public void setEndDate(Calendar endDate) {
        this.endDate = endDate;
    }

    /**
     * Check if the task has startDate.
     *
     * @return if the task has startDate
     */
    public boolean hasStartDate() {
        return (this.startDate != null);
    }

    /**
     * Check if the task has endDate.
     *
     * @return if the task has endDate
     */
    public boolean hasEndDate() {
        return (this.endDate != null);
    }

    /**
     * Check if the task has DateRange.
     *
     * @return if the task has DateRange
     */
    public boolean hasDateRange() {
        return (this.startDate != null && this.endDate != null);
    }

    /**
     * Check if the task has endDate.
     *
     * @return if the task has endDate
     */
    public boolean isDeadline() {
        return (!hasStartDate() && hasEndDate());
    }

    /**
     * Overwrite the default to string value of task Formatted for RubberDuck
     * console design.
     *
     * @return String value of DatePair
     */
    @Override
    public String toString() {
        String formattedStartDate, formattedEndDate;
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd-MMM-YYYY HH:ss",
                                                           Locale.US);

        if (hasStartDate()) {
            formattedStartDate = dateFormat.format(startDate.getTime());
        } else {
            formattedStartDate = "[No Start Date]";
        }

        if (hasEndDate()) {
            formattedEndDate = dateFormat.format(endDate.getTime());
        } else {
            formattedEndDate = "[No End Date]";
        }

        return String.format("%s %s", formattedStartDate, formattedEndDate);

    }

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\DatePair.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\DatePair.java
	 */

    /**
     * Check if any end date in the DateList has already past the current date
     * and time during execution.
     *
     * @param dateList the ArrayList of DatePair
     * @return true if there is a date that has already past else false
     */
    public static boolean isDateBeforeNow(ArrayList<DatePair> dateList) {
        if (dateList.size() > EMPTY_ARRAYLIST_SIZE) {
            for (DatePair dp : dateList) {
                if (dp.getEndDate().before(Calendar.getInstance())) {
                    return true;
                }
            }
            return false;
        }
        return false;
    }

}

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\DatePair.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\Task.java
	 */

/**
 * This task class is used to represent a single task object which stores all
 * relevant information about the task and provide the needed getters and
 * setters for retrieval and storage.
 */
public class Task implements Serializable, Comparable<Task> {

    private String description;
    private ArrayList<DatePair> dateList;
    private boolean isDone;
    private String uuid;
    private Calendar lastUpdate;

    private static final int BIGGER = 1;
    private static final int SMALLER = -1;
    private static final int SAME = 0;

    /**
     * Creates a task with no fields. This should only be used by Java Bean.
     */
    public Task() {

    }

    /**
     * Creates a task with notes field only.
     *
     * @param description notes about the task
     */

    public Task(String description) {
        this(description, new ArrayList<DatePair>());
    }

    /**
     * Creates a task with notes and DatePair fields.
     *
     * @param description about the task
     * @param dateList    of possible DatePair
     */
    public Task(String description, ArrayList<DatePair> dateList) {
        this.description = description;
        this.dateList = dateList;
        this.isDone = false;
        updateLastUpdate();
        resetUuid();
    }

    /**
     * Change the description of the notes.
     *
     * @param description of the task
     */
    public void setDescription(String description) {
        this.description = description;
        updateLastUpdate();
    }

    /**
     * Returns the description of the class.
     *
     * @return the description of the class
     */
    public String getDescription() {
        return description;
    }

    /**
     * Set a new dateList of the Task object.
     *
     * @param dateList of possible DatePair
     */

    public void setDateList(ArrayList<DatePair> dateList) {
        this.dateList = dateList;
        updateLastUpdate();
    }

    /**
     * Check if there is at least a start date or end date.
     *
     * @return if there exist at least a date
     */
    public boolean hasDate() {
        for (DatePair dp : dateList) {
            if (dp.hasEndDate() || dp.hasStartDate()) {
                return true;
            }
        }
        return false;
    }

    /**
     * Returns an ArrayList of DatePair.
     *
     * @return the dateList of possible DatePair
     */

    public ArrayList<DatePair> getDateList() {
        return dateList;
    }

    /**
     * Add an end date to the task without a start date.
     *
     * @param endDate the dateline of the task
     */

    public void addEndDate(GregorianCalendar endDate) {
        DatePair dp = new DatePair(endDate);
        dateList.add(dp);
        updateLastUpdate();
    }

    /**
     * Adds another DatePair into DatePairList.
     *
     * @param datePair datePair to add
     */
    public void addDatePair(DatePair datePair) {
        dateList.add(datePair);
        updateLastUpdate();
    }

    /**
     * Update the task to set it to complete.
     *
     * @param isDone whether the task is completed
     */

    public void setIsDone(boolean isDone) {
        this.isDone = isDone;
        updateLastUpdate();
    }

    /**
     * Check if the status is completed.
     *
     * @return if the task is completed
     */

    public boolean getIsDone() {
        return isDone;
    }

    /**
     * Return UUID of the task.
     *
     * @return UUID as String
     */
    public String getUuid() {
        return uuid;
    }

    /**
     * Set UUID of the task.
     *
     * @param uuid UUID to be set
     */
    public void setUuid(String uuid) {
        this.uuid = uuid;
        updateLastUpdate();
    }

    /**
     * Get the task last updateTime as Calendar.
     *
     * @return Calendar format of last update time of the task
     */
    public Calendar getLastUpdate() {
        return this.lastUpdate;
    }

    /**
     * Update the task last updateTime (For Google Sync).
     */
    public void updateLastUpdate() {
        this.lastUpdate = Calendar.getInstance();
    }

    /**
     * Check if the dateList is empty.
     *
     * @return if the dateList is empty
     */
    public boolean isDateListEmpty() {
        return dateList.isEmpty();
    }

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\Task.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\Task.java
	 */

    /**
     * Compare both task by their deadline.
     * <p/>
     * Schedule Task > Deadline Task > Floating Task
     *
     * @param o the task object to be compared with the argument
     * @return int ,  0 = equal, -1 = smaller, 1 = bigger
     */
    @Override
    public int compareTo(Task o) {
        assert (o != null);

        if (this.isSchedule() && !o.isSchedule()) {
            return SMALLER;
        } else if (!this.isSchedule() && o.isSchedule()) {
            return BIGGER;
        }

        if (this.isFloatingTask() && o.isFloatingTask()) {
            return SAME;
        } else if (this.isFloatingTask()) {
            return BIGGER;
        } else if (o.isFloatingTask()) {
            return SMALLER;
        }

        return this.getEarliestDate().compareTo(o.getEarliestDate());

    }

    /**
     * Method used to check whether a task has any potential conflicting
     * schedule in current database.
     *
     * @param dbManager DatabaseManager object to interact with
     * @return true if there is a conflict else false
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    public boolean checkConflictWithDB(DatabaseManager<Task> dbManager,
                                       long thisTaskId) throws IOException {
        if (isFloatingTask() || isDeadline()) {
            return false;
        }

        ArrayList<Long> validIDList = dbManager.getValidIdList();
        for (Long i : validIDList) {
            Task storedTask = dbManager.getInstance(i);
            if (i != thisTaskId && !storedTask.getIsDone()) {
                if (hasConflictWith(storedTask)) {
                    return true;
                }
            }
        }

        return false;
    }
}

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\common\datatransfer\Task.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\AddCommand.java
	 */

/**
 * Concrete Command Class that can be executed to add a new task (floating,
 * deadline, schedule and tentative) into the database.
 */
public class AddCommand extends Command {

    private static final String MESSAGE_ADD_FLOAT_SUCCESS =
        "\"%s\" has been successfully added.";
    private static final String MESSAGE_ADD_DEADLINE_SUCCESS =
        "\"%s\" has been successfully added on %s.";
    private static final String MESSAGE_ADD_TIMED_SUCCESS =
        "\"%s\" has been successfully added from %s.";
    private static final String MESSAGE_ADD_TENTATIVE_SUCCESS =
        "\"%s\" has been successfully added tentatively on your specified dates.";
    private static final String MESSAGE_ADD_PAST =
        "\"%s\" cannot be added as the end date has already passed the current time.";
    private static final String MESSAGE_ERROR_WRONG_TASK_TYPE =
        "Tentative task must be strictly for schedule(s) only. No deadline(s) are allowed.";
    private static final String MESSAGE_SCHEDULE_CONFLICT =
        "Please note that there are conflicting schedule(s). Plan well!";
    private static final String MESSAGE_ADD_START =
        "Adding tasks into database...";
    private static final String JOURNAL_MESSAGE_ADD =
        "Added task \"%s\"";

    private String description;
    private ArrayList<DatePair> datePairs;

    /**
     * Public constructor for AddCommand that accepts description and the list
     * of DatePairs.
     *
     * @param description of the task
     * @param datePairs   list of datePairs if any
     */
    public AddCommand(String description, ArrayList<DatePair> datePairs) {
        this.description = description;
        this.datePairs = datePairs;
    }

    /**
     * Getter method for description.
     *
     * @return description as String
     */
    protected String getDescription() {
        return description;
    }

    /**
     * Getter method for datePairs.
     *
     * @return datePairs as ArrayList<DatePair>
     */
    protected ArrayList<DatePair> getDatePairs() {
        return datePairs;
    }

    /**
     * Create and add the task to the database.
     *
     * @return the correct response back to the user
     * @throws IOException DBManager has encountered an IO Error
     */
    @Override
    public Response execute() throws IOException {
        assert datePairs != null;
        assert description != null;
        assert !description.equals("");

        if (DatePair.isDateBeforeNow(datePairs)) {
            String errorMessage = ColorFormatter.format(
                String.format(MESSAGE_ADD_PAST, description), Color.RED);
            return new Response(errorMessage, false);
        }

        Task task = new Task(description, datePairs);

        if (!task.checkValidity()) {
            String errorMessage = ColorFormatter.format(
                MESSAGE_ERROR_WRONG_TASK_TYPE, Color.RED);
            return new Response(errorMessage, false);
        }

        String recordDesc = Formatter.limitDescription(task.getDescription());

        LOGGER.info(MESSAGE_ADD_START);
        long id = getDbManager().modify(null, task,
                                        String.format(JOURNAL_MESSAGE_ADD,
                                                      recordDesc));
        assert id >= 0 : "ID should never be a negative number.";

        boolean hasConflict = task.checkConflictWithDB(getDbManager(), id);

        /* Build Response to the User */
        StringBuilder messages = new StringBuilder();
        if (task.isTentative()) {
            messages.append(ColorFormatter.format(String.format(
                MESSAGE_ADD_TENTATIVE_SUCCESS, recordDesc), Color.YELLOW));
        } else if (task.isFloatingTask()) {
            messages.append(ColorFormatter.format(
                String.format(MESSAGE_ADD_FLOAT_SUCCESS, recordDesc),
                Color.YELLOW));
        } else if (task.isDeadline()) {
            messages.append(ColorFormatter.format(String.format(
                MESSAGE_ADD_DEADLINE_SUCCESS, recordDesc,
                task.getDateString()), Color.YELLOW));
        } else if (task.isSchedule()) {
            messages.append(ColorFormatter.format(String.format(
                MESSAGE_ADD_TIMED_SUCCESS, recordDesc,
                task.getDateString()), Color.YELLOW));
        }

        LOGGER.info(messages.toString());

        if (hasConflict) {
            messages.append(System.lineSeparator());
            messages.append(ColorFormatter.format(MESSAGE_SCHEDULE_CONFLICT,
                                                  Color.RED));
        }

        Response res = getPreviousDisplayCommand().execute();
        res.setMessages(messages.toString());
        return res;
    }
}

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\AddCommand.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\SearchCommand.java
	 */

/**
 * Concrete Command Class that can be executed to search the data store for
 * tasks containing the provided keyword and returns back the task details.
 */
public class SearchCommand extends Command {

    private static final String MESSAGE_SEARCH_RESULT =
        "%s task with \"%s\" has been found.";

    private static final int FIRST_CHAR = 0;
    private static final int SECOND_CHAR = 1;
    private static final int CHAR_LENGTH_OFFSET = 1;
    private static final int EMPTY_KEYWORDS_LENGTH = 2;
    private static final int ONE_WORD = 1;

    /* Information required for search */
    private String keyword;

    /**
     * Public constructor of SearchCommand.
     *
     * @param keyword that is used to search for the task
     */
    public SearchCommand(String keyword) {
        this.keyword = keyword;
    }

    /**
     * Getter method for keyword.
     *
     * @return String object
     */
    protected String getKeyword() {
        return keyword;
    }

    /**
     * Search for task based on description and return a Response containing
     * formatted string of tasks back to parent.
     *
     * @return Response object containing formatted tasks
     * @throws IOException that might be thrown from dbManager
     */
    @Override
    public Response execute() throws IOException {
        setPreviousDisplayCommand(this);
        getDisplayedTasksList().clear();

        for (Long databaseId : getDbManager().getValidIdList()) {
            boolean isFound = false;
            String taskDescription =
                getDbManager().getInstance(databaseId).getDescription();
            taskDescription = taskDescription.toLowerCase();
            StringTokenizer taskDescriptions =
                new StringTokenizer(taskDescription);
            StringTokenizer keywords =
                new StringTokenizer(keyword.toLowerCase());

            if (keyword.length() > EMPTY_KEYWORDS_LENGTH &&
                keyword.charAt(FIRST_CHAR) == '\"' &&
                keyword.charAt(keyword.length() - CHAR_LENGTH_OFFSET) == '\"') {

                String modifiedKeyword = keyword.substring(SECOND_CHAR,
                                                           keyword.length() -
                                                           CHAR_LENGTH_OFFSET);
                isFound = searchExactKeyword(modifiedKeyword, taskDescriptions);

            } else if (keywords.countTokens() == ONE_WORD) {
                isFound = searchSingleKeyword(keyword, taskDescription);
            } else {
                isFound = searchMultipleKeyword(keywords, taskDescriptions);
            }
            if (isFound) {
                getDisplayedTasksList().add(databaseId);
            }
        }

        Color headerColor = getDisplayedTasksList().isEmpty() ? Color.RED
                                                              : Color.GREEN;

        StringBuilder viewCount = new StringBuilder();
        viewCount.append(ColorFormatter.format(
            String.format(MESSAGE_SEARCH_RESULT, getDisplayedTasksList().size(),
                          keyword), headerColor));

        String taskData = Formatter.formatTaskList(getDisplayedTasksList(),
                                                   getDbManager());
        return new Response("", viewCount.toString(), taskData);
    }

    /**
     * Complementing searchMultipleKeyword.
     * <p/>
     * When search are being called, if keyword used in search contains only a
     * single word, this method will be called.
     * <p/>
     * This will actually check if the description itself contains the word and
     * return the value immediately
     * <p/>
     * To eliminate the getting unwanted result due to searching with
     * meaningless keywords
     *
     * @param keyword
     * @param taskDescription
     * @return if the description of the task contains the keyword.
     */
    private boolean searchSingleKeyword(String keyword,
                                        String taskDescription) {
        return taskDescription.toLowerCase().contains(keyword.toLowerCase());
    }

    /**
     * This method allows user to search for exact keyword, thus if " " are
     * used, only description that consist of exact same words will be shown.
     *
     * @param keyword
     * @param taskDescriptions tokenized taskDescription
     * @return if the description of the task contains the keyword.
     */
    private boolean searchExactKeyword(String keyword,
                                       StringTokenizer taskDescriptions) {

        while (taskDescriptions.hasMoreElements()) {

            String nextToken = taskDescriptions.nextToken();
            if (nextToken.equalsIgnoreCase(keyword)) {
                return true;
            }
        }
        return false;
    }

    /**
     * Complementing searchSingleKeyword.
     * <p/>
     * When search are being called, if keyword used in search contains more
     * than a word, this method will be called.
     * <p/>
     * This will actually check if the description itself contains exactly all
     * the keyword as entered by the user
     * <p/>
     * To eliminate the getting unwanted result due to searching with
     * meaningless keywords
     *
     * @param keyword
     * @param taskDescription
     * @return if the description of the task contains the keyword.
     */
    private boolean searchMultipleKeyword(StringTokenizer keywords,
                                          StringTokenizer taskDescriptions) {
        String firstKeyword = keywords.nextToken();
        while (taskDescriptions.hasMoreElements()) {
            if (taskDescriptions.nextToken().equals(firstKeyword)) {
                if (keywords.countTokens() <= taskDescriptions.countTokens()) {
                    // check remaining keyword
                    while (keywords.hasMoreElements()) {
                        if (!keywords.nextToken()
                            .equals(taskDescriptions.nextToken())) {
                            return false;
                        }
                    }
                    return true;
                } else {
                    return false;
                }
            }
        }
        return false;
    }
}

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\SearchCommand.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\ViewCommand.java
	 */

/**
 * Concrete Command Class that can be executed to return related tasks as a
 * formatted String based on various input upon creation.
 */
public class ViewCommand extends Command {

    /**
     * Enumeration of all types of view filter
     */
    public enum ViewFilter {
        FLOATING, DEADLINE, SCHEDULE
    }

    /**
     * Enumeration of all types of view type
     */
    public enum ViewType {
        ALL, DATE, PREV, OVERDUE
    }

    private static final String MESSAGE_VIEWALL_RESULT =
        "You have %s incomplete task(s) in total.";
    private static final String MESSAGE_VIEWDATE_RESULT =
        "You have %s incomplete task(s) %s.";
    private static final String MESSAGE_VIEWALL_CRESULT =
        "You have %s completed task(s) in total.";
    private static final String MESSAGE_VIEWDATE_CRESULT =
        "You have %s completed task(s) %s.";
    private static final String MESSAGE_VIEWOVERDUE_RESULT =
        "You have %s overdue tasks(s) in total.";
    private static final String MESSAGE_DATE_RANGE =
        "from %s to %s";
    private static final String MESSAGE_ONE_DAY =
        "on %s";
    private static final String MESSAGE_VIEWTYPE_TASK_ALERT =
        "Please note that all task have no date, thus it will be omitted in your agenda.";

    private static final int VIEW_FILTER_ALL_SELECTED = 3;
    private static final int VIEW_FILTER_ONE_SELECTED = 1;
    private static final int VIEW_FILTER_NONE_SELECTED = 0;

    private static final ArrayList<ViewFilter> VIEW_SELECTION_ALL =
        new ArrayList<ViewFilter>(
            Arrays.asList(ViewFilter.DEADLINE, ViewFilter.SCHEDULE,
                          ViewFilter.FLOATING));

    private DatePair viewRange;
    private boolean completed;
    private ViewType viewType;
    private ArrayList<ViewFilter> viewSelection;

    /**
     * Public constructor for ViewCommand.
     *
     * @param viewType      the type of view to execute
     * @param completed     true if all completed tasks should be returned
     *                      instead
     * @param viewRange     date range to view tasks in
     * @param viewSelection specified view scope from user
     */
    public ViewCommand(ViewType viewType, boolean completed, DatePair viewRange,
                       ArrayList<ViewFilter> viewSelection) {
        this.viewType = viewType;
        this.completed = completed;
        this.viewRange = viewRange;
        if (viewSelection != null && viewSelection.isEmpty()) {
            this.viewSelection = VIEW_SELECTION_ALL;
        } else {
            this.viewSelection = viewSelection;
        }
    }

    /**
     * Getter method for viewRange.
     *
     * @return viewRange as DatePair
     */
    protected DatePair getViewRange() {
        return viewRange;
    }


    /**
     * Getter method for completed.
     *
     * @return completed as boolean
     */
    protected boolean isCompleted() {
        return completed;
    }

    /**
     * Getter method for viewType.
     *
     * @return viewType as ViewType
     */
    protected ViewType getViewType() {
        return viewType;
    }

    /**
     * Getter method for viewSelection.
     *
     * @return viewSelection as ArrayList
     */
    protected ArrayList<ViewFilter> getViewSelection() {
        return viewSelection;
    }

    /**
     * Check the type of view method requested by user.
     *
     * @return Response object containing the result of the view option
     * @throws IOException that might occur
     */
    @Override
    public Response execute() throws IOException {
        switch (viewType) {
            case ALL:
                return viewAll();

            case DATE:
                return viewByPeriod();

            case OVERDUE:
                return viewOverdue();

            case PREV:
                return viewPrev();

            default:
                throw new UnsupportedOperationException();
        }
    }

    /**
     * Return all the valid task stored in the database.
     *
     * @return Response object containing result of all tasks
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    private Response viewAll() throws IOException {
        assert viewSelection != null;

        getDisplayedTasksList().clear();

        for (int i = 0; i < getDbManager().getValidIdList().size(); i++) {
            Long databaseId = getDbManager().getValidIdList().get(i);
            Task task = getDbManager().getInstance(databaseId);
            if (completed == task.getIsDone() && viewSelection.
                contains(getTaskType(task))) {
                getDisplayedTasksList().add(databaseId);
            }
        }

        Color headerColor = getDisplayedTasksList().isEmpty() ? Color.GREEN
                                                              : Color.YELLOW;

        Color cHeaderColor = getDisplayedTasksList().isEmpty() ? Color.YELLOW
                                                               : Color.GREEN;
        StringBuilder viewCount = new StringBuilder();
        if (completed) {
            String formattedString = String.format(MESSAGE_VIEWALL_CRESULT,
                                                   getDisplayedTasksList().
                                                       size());
            viewCount.append(ColorFormatter.format(formattedString,
                                                   cHeaderColor));
        } else {
            String formattedString = String.format(MESSAGE_VIEWALL_RESULT,
                                                   getDisplayedTasksList()
                                                       .size());
            viewCount.append(ColorFormatter.format(formattedString,
                                                   headerColor));
        }

        setPreviousDisplayCommand(this);
        String taskData = Formatter.formatTaskList(getDisplayedTasksList(),
                                                   getDbManager());
        return new Response("", viewCount.toString() + " "
                                + viewSelectionToString(), taskData);
    }

    /**
     * Return overdue tasks in database, based on user selections
     *
     * @return Response object containing result of all tasks
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    private Response viewOverdue() throws IOException {
        assert viewSelection != null;

        getDisplayedTasksList().clear();

        for (int i = 0; i < getDbManager().getValidIdList().size(); i++) {
            Long databaseId = getDbManager().getValidIdList().get(i);
            Task task = getDbManager().getInstance(databaseId);
            if (taskOverdueValidity(task)) {
                getDisplayedTasksList().add(databaseId);
            }
        }
        Color headerColor = getDisplayedTasksList().isEmpty() ? Color.GREEN
                                                              : Color.YELLOW;
        StringBuilder viewCount = new StringBuilder();
        String formattedString = String.format(MESSAGE_VIEWOVERDUE_RESULT,
                                               getDisplayedTasksList().size());
        viewCount.append(ColorFormatter.format(formattedString, headerColor));

        setPreviousDisplayCommand(this);
        String taskData = Formatter.formatTaskList(getDisplayedTasksList(),
                                                   getDbManager());
        return new Response("" + taskFilterAlert(), viewCount.toString() + " "
                                                    + viewSelectionToString(),
                            taskData);
    }

    /**
     * Checks if the task has a deadline, if it is overdue and if it fits user
     * filter criteria
     *
     * @param task the task to check
     * @return if it fits search criteria
     */
    private boolean taskOverdueValidity(Task task) {
        return (task.isDeadline() || task.isSchedule()) &&
               !task.getIsDone() && viewSelection.contains(getTaskType(task)) &&
               task.getDateList().get(0).getEndDate()
                   .before(Calendar.getInstance());
    }

    /**
     * Searches the Database for a related task that coincides with the
     * dateRange requested.
     *
     * @return Response object containing result of all tasks within range
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    private Response viewByPeriod() throws IOException {
        assert viewSelection != null;
        assert viewRange != null;

        getDisplayedTasksList().clear();
        for (Long databaseId : getDbManager().getValidIdList()) {
            Task task = getDbManager().getInstance(databaseId);
            if (completed == task.getIsDone() && task.hasDate() &&
                viewSelection.contains(getTaskType(task))) {
                if (task.isWithinPeriod(viewRange)) {
                    getDisplayedTasksList().add(databaseId);
                }
            }
        }

        String range = "";
        SimpleDateFormat dateFormat = new SimpleDateFormat("dd MMM", Locale.US);
        if (viewRange.hasDateRange()) {
            String startDate =
                dateFormat.format(viewRange.getStartDate().getTime());
            String endDate =
                dateFormat.format(viewRange.getEndDate().getTime());

            if (!startDate.equals(endDate)) {
                range = String.format(MESSAGE_DATE_RANGE, startDate, endDate);
            } else {
                range = String.format(MESSAGE_ONE_DAY, endDate);
            }
        } else {
            assert false : "This should not occur as there must be a date.";
        }

        Color headerColor = getDisplayedTasksList().isEmpty() ? Color.GREEN
                                                              : Color.YELLOW;
        StringBuilder viewCount = new StringBuilder();
        if (completed) {
            viewCount.append(ColorFormatter.format(String.format(
                MESSAGE_VIEWDATE_CRESULT, getDisplayedTasksList().size(),
                range), headerColor));
        } else {
            viewCount.append(ColorFormatter.format(String.format(
                MESSAGE_VIEWDATE_RESULT, getDisplayedTasksList().size(),
                range), headerColor));
        }

        setPreviousDisplayCommand(this);
        String taskData = Formatter.formatTaskList(getDisplayedTasksList(),
                                                   getDbManager());
        String header = viewCount.toString() + " " + viewSelectionToString();
        return new Response("" + taskFilterAlert(), header, taskData);
    }

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\ViewCommand.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\ViewCommand.java
	 */

    /**
     * Retrieve the viewType based on the task provided.
     *
     * @param task object to get type
     * @return ViewFilter of the object
     */
    private ViewFilter getTaskType(Task task) {
        if (task.isFloatingTask()) {
            return ViewFilter.FLOATING;
        } else if (task.isDeadline()) {
            return ViewFilter.DEADLINE;
        } else {
            return ViewFilter.SCHEDULE;
        }
    }

    /**
     * Returns user required filters in string
     *
     * @return String feedback of user requested filters
     */
    private String viewSelectionToString() {

        String viewSelectionList = "[";

        if (viewSelection.size() == VIEW_FILTER_ALL_SELECTED
            || viewSelection.size() == VIEW_FILTER_NONE_SELECTED) {
            viewSelectionList += "All";
        } else {
            for (int i = 0; i < viewSelection.size(); i++) {
                viewSelectionList += viewSelection.get(i);
                if (i < viewSelection.size() - 1) {
                    viewSelectionList += ", ";
                }
            }
        }
        return ColorFormatter.format(viewSelectionList + "]", Color.CYAN);
    }

    /**
     * Check if it is view by dateRange, and return message to warn that the
     * search will be omitted
     *
     * @return String containing the alert message if there is any
     */
    private String taskFilterAlert() {
        String alert = "";
        if (viewSelection.contains(ViewFilter.FLOATING)) {
            alert += MESSAGE_VIEWTYPE_TASK_ALERT;
        }
        return ColorFormatter.format(alert, Color.RED);
    }
}

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\logic\command\ViewCommand.java





	/**
	 * origin: C:\Users\Jason\Desktop\main\src\rubberduck\menu\UnixInterface.java
	 */

    /**
     * Setup and instantiates the ConsoleReader from jLine.
     *
     * @return ConsoleReader object
     * @throws IOException occurs when ConsoleReader has problem with output
     */
    private ConsoleReader setupConsoleReader() throws IOException {
        ConsoleReader cr = new ConsoleReader();
        cr.clearScreen();
        cr.setPrompt(DEFAULT_PROMPT);
        setCompleter(cr);
        setKeybinding(cr);
        return cr;
    }

	// End of segment: C:\Users\Jason\Desktop\main\src\rubberduck\menu\UnixInterface.java





