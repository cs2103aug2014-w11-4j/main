//@author: a0119504l



	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void addTentativeTask() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();

        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp = new DatePair(date, date2);
        datePairList.add(dp);

        Calendar date3 = Calendar.getInstance();
        Calendar date4 = Calendar.getInstance();
        date3.add(Calendar.DAY_OF_YEAR, 2);
        date4.add(Calendar.DAY_OF_YEAR, 3);
        DatePair dp2 = new DatePair(date3, date4);
        datePairList.add(dp2);

        Calendar date5 = Calendar.getInstance();
        Calendar date6 = Calendar.getInstance();
        date5.add(Calendar.DAY_OF_YEAR, 3);
        date6.add(Calendar.DAY_OF_YEAR, 4);
        DatePair dp3 = new DatePair(date5, date6);
        datePairList.add(dp3);

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            datePairList);
        String actual = addCommand.execute().getMessages()[0];

        String expected =
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.";
        assertTrue(actual.contains(expected));
    }

    /**
     * add task which deadline have passed
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void addTaskPassed() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        date.add(Calendar.DAY_OF_MONTH, -5);
        DatePair dp = new DatePair(date);
        datePairList.add(dp);

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            datePairList);
        String actual = addCommand.execute().getMessages()[1];

        String expected = "end date has already passed the current time.";
        assertTrue(actual.contains(expected));
    }

    /**
     * add conflict task test the warning message came out
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void addConflictTask() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        ArrayList<DatePair> datePairList2 = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();

        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp = new DatePair(date, date2);
        datePairList.add(dp);
        datePairList2.add(dp);

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            datePairList);
        addCommand.execute();
        AddCommand addCommand2 = new AddCommand(
            "Lonsectetur adipiscing elit.",
            datePairList2);
        String actual = addCommand2.execute().getMessages()[2];

        String expected =
            "Please note that there are conflicting schedule(s)";
        assertTrue(actual.contains(expected));
    }

    /**
     * add wrong task type with multiple deadlines
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void addTaskWrongType() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();
        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp = new DatePair(date);
        DatePair dp2 = new DatePair(date2);
        datePairList.add(dp);
        datePairList.add(dp2);

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            datePairList);
        String actual = addCommand.execute().getMessages()[0];

        String expected =
            "Tentative task must be strictly for schedule(s) only.";
        assertTrue(actual.contains(expected));
    }

    /**
     * Search for keyword in description
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void searchKeywordNotExistTest() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        addCommand.execute();

        SearchCommand searchCommand = new SearchCommand("apple");
        String actual = searchCommand.execute().getViewCount();
        String expected = "0 task with \"apple\" has been found.";
        assertTrue(actual.contains(expected));
    }

    /**
     * Search for keyword not exist Applying new enhance search function where
     * description are tokenized before being searched.
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void helpTest() throws IOException {
        HelpCommand command = new HelpCommand(false, null);
        String actual = command.execute().getMessages()[0];

        String expected = "Here are for the available commands in RubberDuck.";
        assertTrue(actual.contains(expected));
    }

    /**
     * Test specific help command
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void helpSpecificTest() throws IOException {
        HelpCommand command = new HelpCommand(true, "add");
        String actual = command.execute().getMessages()[0];
        String expected = "More information about your queried command.";
        assertTrue(actual.contains(expected));
    }

    /**
     * Test invalid help command
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void helpInvalidCommandTest() throws IOException {
        HelpCommand command = new HelpCommand(true, "abc");
        String actual = command.execute().getMessages()[0];
        String expected = "No such command/alias.";
        assertTrue(actual.contains(expected));

    }

    /**
     * Test invalid command
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void InvalidCommandTest() throws IOException {
        InvalidCommand command = new InvalidCommand("abc");
        String actual = command.execute().getMessages()[0];
        String expected = "abc";
        assertTrue(actual.contains(expected));

    }

    /**
     * Delete exist task
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void deleteExistTask() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        addCommand.execute();

        DeleteCommand deleteCommand = new DeleteCommand(1);
        deleteCommand.execute();
        assertEquals(0, Command.getDbManager().getValidIdList().size());
    }

    /**
     * Delete not exist task
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void deleteNotExistTask() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        addCommand.execute();

        DeleteCommand deleteCommand = new DeleteCommand(2);

        String expected = deleteCommand.execute().getMessages()[0];
        assertTrue(expected.contains(ColorFormatter.
            format("This is not a valid task ID to delete.", Color.RED)));
    }

    /**
     * update the task description
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void updateTaskDescription() throws IOException {
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);

        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        addCommand.execute();
        UpdateCommand updateCommand = new UpdateCommand(1,
                                                        "Lorem ipsum dolor sit amet.",
                                                        dpList);
        updateCommand.execute();
        String actual = Command.getDbManager()
            .getInstance(Command.getDisplayedTasksList().get(0))
            .getDescription();
        String expected = "Lorem ipsum dolor sit amet.";
        assertEquals(expected, actual);
    }

    /**
     * update the task dateList
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void updateTaskDate() throws IOException {
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        addCommand.execute();

        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();
        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp2 = new DatePair(date, date2);
        datePairList.add(dp2);

        UpdateCommand updateCommand = new UpdateCommand(1,
                                                        "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
                                                        datePairList);
        updateCommand.execute();
        String actual = Command.getDbManager()
            .getInstance(Command.getDisplayedTasksList().get(0)).getDateList()
            .toString();
        String expected = datePairList.toString();
        assertEquals(expected, actual);
    }

    /**
     * update the task does not exist
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void updateTaskNotExist() throws IOException {
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        addCommand.execute();
        UpdateCommand updateCommand = new UpdateCommand(2,
                                                        "Lorem ipsum dolor sit amet.",
                                                        dpList);
        String expected = updateCommand.execute().getMessages()[0];
        String actual = ColorFormatter.format("You have input an invalid ID.",
                                              Color.RED);

        assertTrue(expected.contains(actual));
    }

    /**
     * update to wrong task type with multiple deadlines
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void updateTaskWrongType() throws IOException {
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        addCommand.execute();

        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();
        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp = new DatePair(date);
        DatePair dp2 = new DatePair(date2);
        datePairList.add(dp);
        datePairList.add(dp2);

        UpdateCommand updateCommand = new UpdateCommand(1,
                                                        "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
                                                        datePairList);
        String actual = updateCommand.execute().getMessages()[0];
        String expected =
            ColorFormatter.format("You have input an invalid task type.",
                                  Color.RED);

        assertTrue(actual.contains(expected));
    }

    /**
     * update task date which has passed
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void updateTaskPassed() throws IOException {
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        addCommand.execute();

        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        date.add(Calendar.DAY_OF_MONTH, -5);
        DatePair dp = new DatePair(date);
        datePairList.add(dp);

        UpdateCommand updateCommand = new UpdateCommand(1,
                                                        "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
                                                        datePairList);
        String actual = updateCommand.execute().getMessages()[0];
        String expected = ColorFormatter.format(
            "You cannot update the end date that has already passed.",
            Color.RED);
        assertEquals(expected, actual);
    }

    /**
     * update task with conflict date
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void updateTaskConflict() throws IOException {

        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);

        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        ArrayList<DatePair> datePairList2 = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();

        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp = new DatePair(date, date2);
        datePairList.add(dp);

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            datePairList);
        addCommand.execute();
        AddCommand addCommand2 = new AddCommand(
            "Lonsectetur adipiscing elit.",
            datePairList2);
        addCommand2.execute();
        datePairList2.add(dp);
        UpdateCommand updateCommand = new UpdateCommand(2,
                                                        "Lorem ipsum dolor sit amet.",
                                                        datePairList2);
        String actual = updateCommand.execute().getMessages()[1];
        String expected =
            "Please note that there are conflicting schedule(s).";
        assertTrue(actual.contains(expected));
    }

    /**
     * mark task as completed
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void markTaskUncompleted() throws IOException {
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        addCommand.execute();

        MarkCommand markCommand = new MarkCommand(1);
        markCommand.execute();

        ViewCommand viewCommandComplete =
            new ViewCommand(ViewCommand.ViewType.ALL, true, null, viewChoice);
        viewCommandComplete.execute();

        MarkCommand markCommandAgain = new MarkCommand(1);
        markCommandAgain.execute();

        ViewCommand viewCommandAgain =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommandAgain.execute();

        boolean actual = Command.getDbManager()
            .getInstance(Command.getDisplayedTasksList().get(0))
            .getIsDone();
        boolean expected = false;
        assertEquals(actual, expected);
    }

    /**
     * mark task as completed
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void markTaskCompleted() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();

        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        addCommand.execute();

        MarkCommand markCommand = new MarkCommand(1);
        markCommand.execute();

        ViewCommand viewCommandComplete =
            new ViewCommand(ViewCommand.ViewType.ALL, true, null, viewChoice);
        viewCommandComplete.execute();

        boolean actual = Command.getDbManager()
            .getInstance(Command.getDisplayedTasksList().get(0))
            .getIsDone();
        boolean expected = true;
        assertEquals(actual, expected);
    }

    /**
     * mark task does not exist
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void markTaskNotExist() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        ArrayList<DatePair> dpList = new ArrayList<DatePair>();
        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            dpList);
        addCommand.execute();
        MarkCommand markCommand = new MarkCommand(2);
        String actual = markCommand.execute().getMessages()[0];

        String expected = ColorFormatter.
            format("You have input an invalid ID.", Color.RED);
        assertTrue(actual.contains(expected));
    }

    /**
     * confirm task
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void confirmTask() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();

        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp = new DatePair(date, date2);
        datePairList.add(dp);

        Calendar date3 = Calendar.getInstance();
        Calendar date4 = Calendar.getInstance();
        date3.add(Calendar.DAY_OF_YEAR, 2);
        date4.add(Calendar.DAY_OF_YEAR, 3);
        DatePair dp2 = new DatePair(date3, date4);
        datePairList.add(dp2);

        Calendar date5 = Calendar.getInstance();
        Calendar date6 = Calendar.getInstance();
        date5.add(Calendar.DAY_OF_YEAR, 3);
        date6.add(Calendar.DAY_OF_YEAR, 4);
        DatePair dp3 = new DatePair(date5, date6);
        datePairList.add(dp3);

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            datePairList);
        addCommand.execute();

        ConfirmCommand confirmCommand = new ConfirmCommand(1, 2);
        confirmCommand.execute();

        String actual = Command.getDbManager()
            .getInstance(Command.getDisplayedTasksList().get(0))
            .getDateList()
            .get(0)
            .toString();
        String expected = dp2.toString();

        assertEquals(expected, actual);
    }

    /**
     * confirm task which does not exist
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void confirmTaskNotExist() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();

        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp = new DatePair(date, date2);
        datePairList.add(dp);

        Calendar date3 = Calendar.getInstance();
        Calendar date4 = Calendar.getInstance();
        date3.add(Calendar.DAY_OF_YEAR, 2);
        date4.add(Calendar.DAY_OF_YEAR, 3);
        DatePair dp2 = new DatePair(date3, date4);
        datePairList.add(dp2);

        Calendar date5 = Calendar.getInstance();
        Calendar date6 = Calendar.getInstance();
        date5.add(Calendar.DAY_OF_YEAR, 3);
        date6.add(Calendar.DAY_OF_YEAR, 4);
        DatePair dp3 = new DatePair(date5, date6);
        datePairList.add(dp3);

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            datePairList);
        addCommand.execute();

        ConfirmCommand confirmCommand = new ConfirmCommand(2, 2);
        String actual = confirmCommand.execute().getMessages()[0];

        String expected = ColorFormatter.
            format("You have input an invalid task ID.", Color.RED);

        assertTrue(actual.contains(expected));
    }

    /**
     * confirm task not tentative
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void confirmTaskNotTentative() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();

        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp = new DatePair(date, date2);
        datePairList.add(dp);

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            datePairList);
        addCommand.execute();

        ConfirmCommand confirmCommand = new ConfirmCommand(1, 2);
        String actual = confirmCommand.execute().getMessages()[1];

        String expected = "does not need confirmation.";
        assertTrue(actual.contains(expected));
    }

    /**
     * confirm task invalid date id
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void confirmTaskInvalidDateId() throws IOException {
        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);
        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();

        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp = new DatePair(date, date2);
        datePairList.add(dp);

        Calendar date3 = Calendar.getInstance();
        Calendar date4 = Calendar.getInstance();
        date3.add(Calendar.DAY_OF_YEAR, 2);
        date4.add(Calendar.DAY_OF_YEAR, 3);
        DatePair dp2 = new DatePair(date3, date4);
        datePairList.add(dp2);

        Calendar date5 = Calendar.getInstance();
        Calendar date6 = Calendar.getInstance();
        date5.add(Calendar.DAY_OF_YEAR, 3);
        date6.add(Calendar.DAY_OF_YEAR, 4);
        DatePair dp3 = new DatePair(date5, date6);
        datePairList.add(dp3);

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            datePairList);
        addCommand.execute();

        ConfirmCommand confirmCommand = new ConfirmCommand(1, 4);
        String actual = confirmCommand.execute().getMessages()[0];

        String expected = ColorFormatter.
            format("You have input an invalid date ID.", Color.RED);

        assertTrue(actual.contains(expected));
    }

    /**
     * confirm task with conflict date
     */
	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\test\rubberduck\logic\command\CommandTest.java
	 */

    @Test
    public void confirmTaskConflict() throws IOException {

        ArrayList<ViewCommand.ViewFilter> viewChoice =
            new ArrayList<ViewCommand.ViewFilter>();
        viewChoice.add(ViewCommand.ViewFilter.DEADLINE);
        viewChoice.add(ViewCommand.ViewFilter.SCHEDULE);
        viewChoice.add(ViewCommand.ViewFilter.FLOATING);
        ViewCommand viewCommand =
            new ViewCommand(ViewCommand.ViewType.ALL, false, null, viewChoice);
        viewCommand.execute();
        Command.setPreviousDisplayCommand(viewCommand);

        ArrayList<DatePair> datePairList = new ArrayList<DatePair>();
        ArrayList<DatePair> datePairList2 = new ArrayList<DatePair>();
        Calendar date = Calendar.getInstance();
        Calendar date2 = Calendar.getInstance();

        date.add(Calendar.DAY_OF_YEAR, 1);
        date2.add(Calendar.DAY_OF_YEAR, 2);
        DatePair dp = new DatePair(date, date2);
        datePairList.add(dp);

        Calendar date3 = Calendar.getInstance();
        Calendar date4 = Calendar.getInstance();
        date3.add(Calendar.DAY_OF_YEAR, 2);
        date4.add(Calendar.DAY_OF_YEAR, 3);
        DatePair dp2 = new DatePair(date3, date4);
        datePairList.add(dp2);

        Calendar date5 = Calendar.getInstance();
        Calendar date6 = Calendar.getInstance();
        date5.add(Calendar.DAY_OF_YEAR, 3);
        date6.add(Calendar.DAY_OF_YEAR, 4);
        DatePair dp3 = new DatePair(date5, date6);
        datePairList.add(dp3);

        datePairList2.add(dp2);

        AddCommand addCommand2 = new AddCommand(
            "Lonsectetur adipiscing elit.",
            datePairList2);
        addCommand2.execute();

        AddCommand addCommand = new AddCommand(
            "Lorem ipsum dolor sit amet, consectetur adipiscing elit.",
            datePairList);
        addCommand.execute();

        datePairList2.add(dp);
        ConfirmCommand confirmCommand = new ConfirmCommand(1, 2);
        String actual = confirmCommand.execute().getMessages()[2];
        String expected =
            "Please note that there are conflicting schedule(s).";
        assertTrue(actual.contains(expected));
    }

	// End of segment: E:\main\test\rubberduck\logic\command\CommandTest.java





	/**
	 * origin: E:\main\src\rubberduck\logic\command\Command.java
	 */

    /**
     * Check whether given task ID is being displayed.
     *
     * @param displayedId the task ID
     * @return true when it is being displayed else false
     */
    protected static boolean isValidDisplayedId(int displayedId) {
        return !(displayedId > displayedTasksList.size() || displayedId <= 0 ||
                 displayedTasksList.get(displayedId - 1) == -1);
    }

	// End of segment: E:\main\src\rubberduck\logic\command\Command.java





	/**
	 * origin: E:\main\src\rubberduck\logic\command\ConfirmCommand.java
	 */

/**
 * Concrete Command Class that can be executed to confirm the a tentative task
 * given a task id displayed on the screen to the user.
 */
public class ConfirmCommand extends Command {

    private static final String MESSAGE_CONFIRM =
        "\"%s\" has been confirmed from %s.";
    private static final String MESSAGE_ERROR_WRONG_TASK_ID =
        "You have input an invalid task ID.";
    private static final String MESSAGE_ERROR_NOT_TENTATIVE =
        "\"%s\" is not tentative and does not need confirmation.";
    private static final String MESSAGE_ERROR_WRONG_DATE_ID =
        "You have input an invalid date ID.";
    private static final String MESSAGE_SCHEDULE_CONFLICT =
        "Please note that there are conflicting schedule(s). Plan well!";
    private static final String JOURNAL_MESSAGE_CONFIRM =
        "Confirmed task \"%s\"";

    private int taskId;
    private int dateId;

    /**
     * Public constructor for ConfirmCommand.
     *
     * @param taskId id of the task as displayed in the last view command
     * @param dateId id to be confirmed
     */
    public ConfirmCommand(int taskId, int dateId) {
        this.taskId = taskId;
        this.dateId = dateId;
    }

    /**
     * Getter method for taskId.
     *
     * @return taskId as int
     */
    protected int getTaskId() {
        return taskId;
    }

    /**
     * Getter method for dateId.
     *
     * @return dateId as int
     */
    protected int getDateId() {
        return dateId;
    }

    /**
     * Confirm the date of the tentative task to the database.
     *
     * @return Response object with appropriate feedback to the user
     * @throws IOException that the dbManager may encounter
     */
    @Override
    public Response execute() throws IOException {
        if (!isValidDisplayedId(taskId)) {
            String errorMessage = ColorFormatter.
                format(MESSAGE_ERROR_WRONG_TASK_ID, Color.RED);
            return new Response(errorMessage, false);
        }

        long databaseId = getDisplayedTasksList().get(taskId - 1);

        Task task = getDbManager().getInstance(databaseId);
        String description = Formatter.limitDescription(task.getDescription());
        ArrayList<DatePair> dateList = task.getDateList();

        if (!task.isTentative()) {
            String errorMessage = ColorFormatter.format(
                String.format(MESSAGE_ERROR_NOT_TENTATIVE, description),
                Color.RED);
            return new Response(errorMessage, false);
        }

        if (dateList.size() < dateId) {
            String errorMessage = ColorFormatter.
                format(MESSAGE_ERROR_WRONG_DATE_ID, Color.RED);
            return new Response(errorMessage, false);
        }

        DatePair date = dateList.get(dateId - 1);
        ArrayList<DatePair> newDateList = new ArrayList<DatePair>();
        newDateList.add(date);
        task.setDateList(newDateList);

        long newDatabaseId = getDbManager().
            modify(databaseId, task, String.format(JOURNAL_MESSAGE_CONFIRM,
                                                   description));
        boolean hasConflict =
            task.checkConflictWithDB(getDbManager(), newDatabaseId);
        getDisplayedTasksList().set(taskId - 1, newDatabaseId);

        StringBuilder messages = new StringBuilder();
        messages.append(ColorFormatter.format(
            String.format(MESSAGE_CONFIRM, description,
                          task.getDateString()), Color.YELLOW));
        if (hasConflict) {
            messages.append(System.lineSeparator());
            messages.append(ColorFormatter.format(MESSAGE_SCHEDULE_CONFLICT,
                                                  Color.RED));
        }
        Response res = getPreviousDisplayCommand().execute();
        res.setMessages(messages.toString());
        return res;
    }

}

	// End of segment: E:\main\src\rubberduck\logic\command\ConfirmCommand.java





	/**
	 * origin: E:\main\src\rubberduck\logic\command\DeleteCommand.java
	 */

/**
 * Concrete Command Class that can be executed to delete the task object from
 * database given the task id displayed on screen to the user.
 */
public class DeleteCommand extends Command {

    private static final String MESSAGE_DELETE =
        "\"%s\" has been successfully deleted from RubberDuck.";
    private static final String MESSAGE_ERROR_WRONG_TASK_ID =
        "This is not a valid task ID to delete.";
    private static final String JOURNAL_MESSAGE_DELETE =
        "Deleted task \"%s\"";

    private int taskId;

    /**
     * Public Constructor of DeleteCommand that accepts a task ID.
     *
     * @param taskId task id of the task displayed on screen
     */
    public DeleteCommand(int taskId) {
        this.taskId = taskId;
    }

    /**
     * Getter method for taskId.
     *
     * @return taskId as int
     */
    protected int getTaskId() {
        return taskId;
    }

    /**
     * Delete given task from database if it exist.
     *
     * @return Response with success message and updated table if delete is
     * successful. else Response with error message.
     * @throws IOException occurs when DBManager has encountered an I/O Error
     */
    @Override
    public Response execute() throws IOException {
        if (!isValidDisplayedId(taskId)) {
            String errorMessage = ColorFormatter.
                format(MESSAGE_ERROR_WRONG_TASK_ID, Color.RED);
            return new Response(errorMessage, false);
        }

        long databaseId = getDisplayedTasksList().get(taskId - 1);
        Task oldTask = getDbManager().getInstance(databaseId);
        String oldDesc = Formatter.limitDescription(oldTask.getDescription());
        getDbManager().modify(databaseId, null,
                              String.format(JOURNAL_MESSAGE_DELETE,
                                            oldDesc));
        getDisplayedTasksList().set(taskId - 1, (long) -1);

        StringBuilder messages = new StringBuilder();
        messages.append(ColorFormatter.format(
            String.format(MESSAGE_DELETE, oldDesc), Color.YELLOW));
        Response res = getPreviousDisplayCommand().execute();
        res.setMessages(messages.toString());
        return res;
    }
}

	// End of segment: E:\main\src\rubberduck\logic\command\DeleteCommand.java





	/**
	 * origin: E:\main\src\rubberduck\logic\command\MarkCommand.java
	 */

/**
 * Concrete Command Class that can be executed to mark as completed/incomplete
 * the task object from database given the task id displayed on screen to the
 * user.
 */
public class MarkCommand extends Command {

    private static final String MESSAGE_ERROR_WRONG_TASK_ID =
        "You have input an invalid ID.";
    private static final String JOURNAL_MESSAGE_MARK_AS_COMPLETED =
        "Marked task \"%s\" as completed";
    private static final String JOURNAL_MESSAGE_MARK_AS_INCOMPLETE =
        "Marked task \"%s\" as incomplete";
    private static final String MESSAGE_MARK_COMPLETED =
        "\"%s\" has been marked to completed.";
    private static final String MESSAGE_MARK_INCOMPLETE =
        "\"%s\" has been marked to incomplete.";

    private int taskId;

    /**
     * Public constructor of MarkCommand that accepts task id to determine what
     * the command should mark when executed.
     *
     * @param taskId displayed id of the task
     */
    public MarkCommand(int taskId) {
        this.taskId = taskId;
    }

    /**
     * Getter method of taskId.
     *
     * @return taskId as int
     */
    protected int getTaskId() {
        return taskId;
    }

    /**
     * Mark a task (completed to uncompleted and vice versa).
     *
     * @return message of mark
     * @throws IOException that might occur
     */
    @Override
    public Response execute() throws IOException {
        if (!isValidDisplayedId(taskId)) {
            String errorMessage = ColorFormatter.format(
                MESSAGE_ERROR_WRONG_TASK_ID, Color.RED);
            return new Response(errorMessage, false);
        }

        if (isCompletedTask(taskId)) {
            return markTaskIncomplete(taskId);
        } else {
            return markTaskCompleted(taskId);
        }
    }

    /**
     * Check whether the task is completed.
     *
     * @param displayedId of the task
     * @return true if the task is completed
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    private boolean isCompletedTask(int displayedId) throws IOException {
        long databaseId = getDisplayedTasksList().get(displayedId - 1);
        Task oldTask = getDbManager().getInstance(databaseId);
        return oldTask.getIsDone();
    }

    /**
     * Mark a incomplete task as completed.
     *
     * @param displayedId displayed id of the task
     * @return Response object containing results of the operation
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    private Response markTaskCompleted(int displayedId) throws IOException {
        long databaseId = getDisplayedTasksList().get(displayedId - 1);
        Task oldTask = getDbManager().getInstance(databaseId);
        assert !oldTask.getIsDone() : "Should be incomplete task.";
        oldTask.setIsDone(true);

        String desc = Formatter.limitDescription(oldTask.getDescription());

        long newTaskId = getDbManager().modify(databaseId, oldTask, String
            .format(JOURNAL_MESSAGE_MARK_AS_COMPLETED, desc));
        getDisplayedTasksList().set(displayedId - 1, newTaskId);

        StringBuilder messages = new StringBuilder();
        messages.append(ColorFormatter.format(
            String.format(MESSAGE_MARK_COMPLETED, desc), Color.GREEN));
        Response res = getPreviousDisplayCommand().execute();
        res.setMessages(messages.toString());
        return res;
    }

    /**
     * Mark a completed task as incomplete.
     *
     * @param displayedId displayed id of the task
     * @return Response object containing results of the operation
     * @throws IOException occurs when dbManager encounters a problem with file
     */
    private Response markTaskIncomplete(int displayedId) throws IOException {
        long databaseId = getDisplayedTasksList().get(displayedId - 1);
        Task oldTask = getDbManager().getInstance(databaseId);
        assert oldTask.getIsDone();
        oldTask.setIsDone(false);

        String desc = Formatter.limitDescription(oldTask.getDescription());

        long newTaskId =
            getDbManager().modify(databaseId, oldTask, String.format(
                JOURNAL_MESSAGE_MARK_AS_INCOMPLETE, desc));
        getDisplayedTasksList().set(displayedId - 1, newTaskId);

        StringBuilder messages = new StringBuilder();
        messages.append(ColorFormatter.format(
            String.format(MESSAGE_MARK_INCOMPLETE, desc), Color.RED));
        Response res = getPreviousDisplayCommand().execute();
        res.setMessages(messages.toString());
        return res;
    }
}

	// End of segment: E:\main\src\rubberduck\logic\command\MarkCommand.java





	/**
	 * origin: E:\main\src\rubberduck\logic\command\UpdateCommand.java
	 */

/**
 * Concrete Command Class that can be executed to update the task object from
 * database given the task id displayed on screen to the user.
 */
public class UpdateCommand extends Command {

    private static final String JOURNAL_MESSAGE_UPDATE =
        "Updated task \"%s\"";
    private static final String MESSAGE_UPDATE =
        "\"%s\" has been successfully updated.";
    private static final String MESSAGE_UPDATE_PAST =
        "You cannot update the end date that has already passed.";
    private static final String MESSAGE_ERROR_WRONG_TASK_ID =
        "You have input an invalid ID.";
    private static final String MESSAGE_ERROR_WRONG_TASK_TYPE =
        "You have input an invalid task type.";
    private static final String MESSAGE_SCHEDULE_CONFLICT =
        "Please note that there are conflicting schedule(s). Plan well!";

    private int taskId;
    private String description;
    private ArrayList<DatePair> datePairs;

    /**
     * Public constructor for UpdateCommand.
     *
     * @param taskId      id of the task as displayed in the last view command
     * @param description updated description, if not changed will be null
     * @param datePairs   updated date list, if not changed will be null
     */
    public UpdateCommand(int taskId, String description,
                         ArrayList<DatePair> datePairs) {
        this.taskId = taskId;
        this.description = description;
        this.datePairs = datePairs;
    }

    /**
     * Getter method for taskId.
     *
     * @return taskId as int
     */
    protected int getTaskId() {
        return taskId;
    }

    /**
     * Getter method for description.
     *
     * @return description as String
     */
    protected String getDescription() {
        return description;
    }

    /**
     * Getter method for datePairs.
     *
     * @return datePairs as ArrayList<DatePair>
     */
    protected ArrayList<DatePair> getDatePairs() {
        return datePairs;
    }

    /**
     * Update the task with provided arguments to the database.
     *
     * @return Response containing updated message with the displayed id
     * @throws IOException that might occur
     */
    @Override
    public Response execute() throws IOException {
        if (!isValidDisplayedId(taskId)) {
            String errorMessage = ColorFormatter
                .format(MESSAGE_ERROR_WRONG_TASK_ID, Color.RED);
            return new Response(errorMessage, false);
        }

        if (DatePair.isDateBeforeNow(datePairs)) {
            String errorMessage = ColorFormatter
                .format(MESSAGE_UPDATE_PAST, Color.RED);
            return new Response(errorMessage, false);
        }

        long databaseId = getDisplayedTasksList().get(taskId - 1);

        Task task = getDbManager().getInstance(databaseId);
        String oldDesc = Formatter.limitDescription(task.getDescription());

        if (!description.isEmpty()) {
            task.setDescription(description);
        }

        if (!datePairs.isEmpty()) {
            if (task.isFloatingTask() || task.isDeadline()) {
                task.setDateList(datePairs);
                if (!task.isFloatingTask() && !task.isDeadline()) {
                    task.resetUuid();
                }
            } else {
                task.setDateList(datePairs);
                if (task.isFloatingTask() || task.isDeadline()) {
                    task.resetUuid();
                }
            }
        }

        if (!task.checkValidity()) {
            String errorMessage = ColorFormatter
                .format(MESSAGE_ERROR_WRONG_TASK_TYPE, Color.RED);
            return new Response(errorMessage, false);
        }

        long newDatabaseId = getDbManager()
            .modify(databaseId, task, String.format(JOURNAL_MESSAGE_UPDATE,
                                                    oldDesc));
        boolean hasConflict = task.checkConflictWithDB(getDbManager(),
                                                       newDatabaseId);

        getDisplayedTasksList().set(taskId - 1, newDatabaseId);

        StringBuilder messages = new StringBuilder();
        messages.append(ColorFormatter
                            .format(String.format(MESSAGE_UPDATE, oldDesc),
                                    Color.YELLOW));
        if (hasConflict) {
            messages.append(System.lineSeparator());
            messages.append(ColorFormatter.format(MESSAGE_SCHEDULE_CONFLICT,
                                                  Color.RED));
        }
        Response res = getPreviousDisplayCommand().execute();
        res.setMessages(messages.toString());
        return res;
    }
}

	// End of segment: E:\main\src\rubberduck\logic\command\UpdateCommand.java





